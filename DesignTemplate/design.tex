z
% !TEX root = DesignDocument.tex

\chapter{Design  and Implementation}

\section{Systems Goals}
The goal of this system is to establish a tool chain between CAD files and AR hardware. To this effect, the system must provide a web interface for users to upload CAD files to the cloud to be converted to file types render-able by AR hardware for on-demand downloading and rendering by AR devices.  

\section{System Overview and Description}
%Provide a more detailed description of the major system components without getting too detailed.  This section should contain a high-level block and/or flow diagram of the system highlighting the major components. See Figure~\ref{systemdiagram}. This is a floating figure environment. \LaTeX\ will try to put it close to where it was typeset but will not allow the figure to be split if moving it can not happen.  Figures, tables, algorithms and many other floating environments are automatically numbered and placed in the appropriate type of table of contents.  You can move these and the numbers will update correctly.
CAD software and AR hardware are assumed available for use of this platform. Thus the two primary components of this platform are a website and conversion software. The website is intended to drive both streams of a data flow.The first will be between the user and the cloud. The second will be between the cloud and AR devices calling files by QR code or download link to be rendered.  Between these data streams rests file conversion software that will be used to convert input files to output file types necessary for specific AR hardware. A secondary component to the website is a QR code generator plugin that will be used for generating unique QR codes to associate with uploaded files. See \ref{fig:UMLSystemOverview}.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{UMLSystemOverview.png}
	\caption{System Overview Diagram} 
	\label{fig:UMLSystemOverview}	
\end{figure}

\subsection{Website}
%Describe briefly the role this major component plays in this system. 
This major component of the system will broker all interactions occurring across the platform. A user interface will be used to control the data upstream between the user and the cloud. Functionality will include uploading, updating, and deleting files. The website will provide QR code generation for uploaded files and create an association between an uploaded file and its QR code. When an AR device accesses a file via QR code or download link, a restful API or likewise will ensure the file conversion software is first called before delivering the file to the device to be rendered.  


\subsection{File Conversion}
The file conversion software converts files between common 3D file types. It is designed to be called from the back end of the website.

Table \ref{tab:suportedfiletypes} lists the minimum file types supported.  More may be supported, but those listed are the minimum needed to support the majority of common file types.  
Models created in most common Computer Aided Design software can export to some of the input file types.

\begin{table}[!h]
    \centering
    \begin{tabular}{| c | c |}
        \hline
        Input file type & Output file type \\
        \hline
        .fbx & .fbx \\
        .dae & .dae \\
        .blend & .obj \\ 
        .obj & .stl \\
        .stl & .ply \\
        .ply & \\
        \hline
    \end{tabular}
    \caption{Supported File Types}
    \label{tab:suportedfiletypes}
\end{table}

 \section{Architecture and System Design}
%This is where you will place the overall system design and the architecture.   This section will be very detailed and should be image rich.  There is the old phrase {\it a picture is worth a thousand words}, in this class it could be worth hundreds of points (well if you sum up over the entire team).   One needs to enter the design and why a particular design has been done.   THIS IS THE CORE OF THE COURSE.    
 
 
% {\it It is important for you to say why as much as what.   }
 
   \subsection{Design Selection}
   \paragraph{}
 Many design tools and coding stacks were considered at the beginning of this project.
 The main decisions we had to make were was our development environment and the cloud services.
 
 \paragraph{}
 The first thing that was decided on was the hosting tools.
 We decided on using the Azure cloud hosting tools for the following reasons.

 \begin{itemize}
    \item Allows for simple database and web hosting.
    \item Paid features are offered free to students.
 \end{itemize}

 We also debated on the coding stack to use for the website.
 We went with ASP.NET MVC for the following reasons:
\begin{itemize}
    \item A majority of the developers were familiar with C\# and Visual Studio.
    \item The decision to use Azure made ASP.NET MVC a natural choice, since they are both part of the Microsoft stack.
\end{itemize}

\paragraph{}
The other options we explored were Amazon Web Service for cloud hosting and linux development environment using Python and Django for the backend logic.
We didn't persue these because negative feedback from our own developers as other professional reviews.

 \subsection{Data Flow}
The web interface for users creates a data upstream exists between a web browser and a cloud server. Users may upload, update, and delete remotely hosted files.

Data downstream exists between the cloud server and AR hardware. Data downstream is initiated by users calling file download through QR codes or direct download links. 

When a file us upload, a QR code generator plugin will be activated to generate and deliver a unique QR code to the web interface to be downloaded by the user and stored on the cloud server in association with the related file. 

When a file is accessed by an AR device, conversion software will convert the file to the appropriate AR compatible file type before delivery. This converted file will be stored on the cloud server for a limited time to streamline repeated and multi-user access.
  
\subsection{UML}
 
	\begin{figure}[H]
	 	\centering
		\includegraphics[width=\textwidth]{UML.png}
		\caption{System UML Diagram} 
	 	\label{fig:SystemUML}	
	\end{figure}
    
\subsection{UX}

Upon delivery of the MVP, user experience testing will be conducted once per sprint with five representative client faculty members: Dr. Jeff McGough, Dr. Christer Karlsson, Dr, Adam Piper, Dr. Brent Deschamp, and Dr. King Adkins. User experience testing will include inspection of the elements including, but not limited to, the following:

\begin{itemize}
	\item Appearance
	\item Ease of use
	\item Help and guidance features
	\item Ease of locating control features and elements of interest
	\item Speed of content delivery 
\end{itemize}

 \section{Website}

 \subsection{Overview}
 \paragraph{}
 A major tool in the project is the website interface for hosting the 3D models that users generate.
 The website is where a user will be able to upload their 3D models
 and get the reference tag for that model.
 
 \paragraph{}
 The website is intended to be a full user experience, where they can
 can sign in to view and manage their own content. In the long term view
 this will be a service similar to GitHub, where users can collaberate and share
 their material with friends and co-workers.

\paragraph{}
This website will be making use of Microsoft's ASP.NET stack along with
Azure services for database and website hosting. A more indepth look into 
these tool will be offered below.

\subsection{User Interface}
The user interface is made to be very simple. The final product
UI was decided to be made of five main windows. 
\begin{itemize}
    \item Home Screen
    \begin{itemize}
        \item Here the user will be able to navigate to the different sections of the website.
        \item The user will need to be logged in to navigate to their pages.
        \item It has a link link to the sign in and sign up.
        \item If the user tries to navigate to a page without signing in
        they will be taken to the login page.
    \end{itemize}

    \item Upload Screen
    \begin{itemize}
        \item This is a very simple page where the user can upload their files
        \item Once the file is uploaded a QR code will be showing for a reference to the file.
    \end{itemize}

    \item User, Organization and All Screens
    \begin{itemize}
        \item These screens will all be very similar.
        \item They will allow for the user to search through all
        available models associatated to the section they are in.
    \end{itemize}
\end{itemize}

The wireframes of all of these pages can be found in prototypes and demos section of this document.
You can find refeneces to the wireframes below.
\begin{itemize}
    \item Home Page ~\ref{fig:proto_web_home}
    \item User Page ~\ref{fig:proto_web_user_page}
    \item Organization Page ~\ref{fig:proto_web_organization_home}
    \item Browse All Page ~\ref{fig:proto_web_browse_all_files}
    \item Upload Page ~\ref{fig:proto_web_home}
\end{itemize}

\subsection{Technologies Used}

    As stated earlier in this document, this product is making use
    of the Microsoft environment for its tools. Below is an indepth 
    break down of the tools currently being used:

    \begin{itemize}
    \item ASP.NET MVC
    \begin{itemize}
        \item An MVC web architecture, where the backend logic is writen in controller classes
        that send and recieve data from the client.
        \item It allows for dynamic html pages using a Razor synatax. Razor allows
        you to embed C\# Code into the html and execute logic.
    \end{itemize}
    
    \item Azure
        \begin{itemize}
            \item Microsoft cloud hosting services.
            \item Allows for simple database and web hosting.
            \item Paid features are offered free to students.
        \end{itemize}
    \end{itemize}

    These tools make up the core development of this website. The website is also
    making use of other smaller packages to handles user authentication and database management.

    The website also impliments the file conversion software that is described later.
    The file conversion was written in C++, so it couldn't be compiled with the website.
    The work around was that was used, was the file conversion was compiled into a executable.
    The executable was used through a system command to convert the file.


    \subsection{Data Flow}
    The data flow happens in two main places. It is set up into a Upload controller
    and a Download Controller.

    \begin{itemize}
        \item Upload Controller
        \begin{itemize}
            \item The user browses through the their file system and uploads
            the 3D model that selected.
            \item Once the file is on the server side it is then converted to an
            .fbx and stored for download.
            \item A tag to reference the model is returned to the client.
        \end{itemize}
        
        \item Download Controller
        \begin{itemize}
            \item The client sends the reference tag was given when it was uploaded to the server.
            \item The server takes that tag and finds the assoicated model.
            \item Using the httpresponse datastructure to create the response and send
            the model back to the user.
        \end{itemize}
    \end{itemize}


\subsection{Design Details}

    \subsubsection{Overview}

    The website is written in C\# with the ASP.NET MVC framework. The main logic
    of the website is contained in two controllers
    \begin{itemize}
        \item Upload Controller
        \begin{itemize}
            \item Handles upload from client to the server.
            \item Uses File Conversion executable to convert to .fbx
            \item Stores file on the web.
        \end{itemize}
        \item Download
        \begin{itemize}
            \item Uploads Model tag from client to server.
            \item Finds associated store model.
            \item Returns model to the client.
        \end{itemize}
    \end{itemize}

    \subsubsection{Code Structure}
    As stated before the website is using ASP.NET MVC framework. 
    The logic happens in the controllers and is split up into the upload and download controller.
    
    \paragraph{Parameter Passing}
    \hfill \break
    The main functions that are being used are the upload and download function.
    
    \begin{itemize}
        \item Upload Function
        \begin{itemize}
           \item HttpPostedFileBase - http message sent from client to server containing the file
           \item The message is parsed to retrieve the file and save to the web.
        \end{itemize}

        \item Download Function
        \begin{itemize}
            \item input string ModelTag - string containing the reference tag to the model.
            \item output httpresponse - http message sent from server to client containing the file. 
        \end{itemize}
    \end{itemize}


 \section{File Conversion}

    \subsection{Overview}
    \paragraph{}
    A major tool in the project is the File Conversion Software.  
    The file conversion software aims to read in many different 3D model file types (.fbx, .obj, .dae, ...) and convert them to another desired 3D file type.  
    A brief listing of supported file types is in table \ref{tab:suportedfiletypes}.
    
    \paragraph{}
    This tool is intended to be used on the back end of the website.  Whenever a user uploads a file, it can be converted to a common file type, using this tool.
    When the user requests a download on an AR device, the type may be different than what is stored.  Therefore, the tool will be used to convert the file before
    it is sent to the user.
    
    \paragraph{}
    Since this tool is intended to be used on the backend of a website, it is appropriate to use a command line interface.  
    The flags that can be passed to the program are listed below:
    
    \begin{table}[h]
        \centering
        \begin{tabular}{l  l}
            -i & Input file name (can specify full path), infers the input file type from the name \\
            -o & Name (or full path) to write the converted file, infers the export file type from the name \\
            -odir & The path to the directory, the file name is inferred from the input file name \\
            -t & The file type (.fbx, .obj, .dae, ...) to export to
        \end{tabular}
    \end{table}
    
    Note the -t flag is only needed when using the -odir flag.  The -odir just specifies which directory to write to, but not the file type.
    Therefore, more information is needed in order to export to a file.  The -o flag will parse the file name and extract the file type from the -i file name.
    
    An example command to run:
    
    \begin{center}
        .\textbackslash FileConversion.exe -i C:\textbackslash SomePath\textbackslash someFile.obj -t fbx -odir C:\textbackslash SomeOtherPath\textbackslash
    \end{center}
    
    This will convert a file named someFile.obj located at C:\textbackslash SomePath\textbackslash  to an FBX file named someFile.fbx located at 
    C:\textbackslash SomeOtherPath\textbackslash
    
    \subsubsection{File Type Research}

    The goal for the file type research was to find out what the commond 3D model file types are, and what is commonly used with AR devices.  Another goal was to determine a common file type for all file types on the website.

    \paragraph{OBJ}
    The OBJ filetype (Wavefront OBJ) stores a list of verticies, and constructs faces using the verticies.  OBJ supports textures, applied to each face, that are stored in a seperate MTL file.  Each face in the OBJ file can reference a material in the MTL file to provide the texturing needed.

    \paragraph{STL}
    The STL file type (sterolithography) stores a list of verticies and forms triangles to form the surfaces of an object.  This file type does not support textures.  It is commonly used in 3D printing.

    \paragraph{DAE}
    The DAE file type (Collada) uses XML to store a 3D model.  It supports textures and animations imbedded in the file.  Therefore, a model with textures and/or animations are stored in a single file.

    \paragraph{FBX}
    The FBX file type (Autodesk FilmBox) is a propriatary file format for Autodesk.  It is commonly used, and is supported, by many different AR devices.

    \paragraph{Conculsions}
    The above file types were found to be the most common.  The intermediate file type was agreed to be DAE.  It supported the most features while encapsulating all the data in a single file.

    \subsection{Technologies Used}
    
    The code for the file conversion toolset is written in C++.  There are two main external libraries used:
    \begin{itemize}
        \item Open Asset Import Library (assimp)
        \begin{itemize}
            \item \url{http://assimp.org/main_downloads.html}
        \end{itemize}

        \item FBX SDK
        \begin{itemize}
            \item \url{http://usa.autodesk.com/adsk/servlet/pc/item?siteID=123112&id=26416244}
        \end{itemize}
    \end{itemize}

    Multiple librarires are needed to support the file types that are necessary for common AR rendering.  In the Microsoft Hololens, the default
    3D viewer supports FBX files very easily.  Therefore, it was decided that the conversion software needed to export to FBX.  The best tool to do 
    so is the FBX SDK, since FBX is a propriatary file format from Autodesk.  However, the FBX SDK has a very limited range of file types it will read and write.
    Therefore, the Open Asset Import Library is used to better support a wide array of file types.  So in using assimp and the FBX SDK together,
    the conversion software can support a wide range of both import and export file types.

    \subsection{Data Flow}
        There are four main paths data can flow.
        \begin{itemize}
            \item assimp
            \begin{itemize}
                \item import and export all with the assimp library
            \end{itemize}
            
            \item FBX SDK
            \begin{itemize}
                \item import and export all with the FBX SDK library
            \end{itemize}

            \item assimp $\rightarrow$ FBX SDK
            \begin{itemize}
                \item import with assimp, export to temporary file type
                \item import temporary file with FBX SDK, export to final file 
            \end{itemize}

            \item FBX SDK $\rightarrow$ assimp
            \begin{itemize}
                \item import with FBX SDK, export to temporary file type
                \item import temporary file with assimp, export to final file 
            \end{itemize}
        \end{itemize}
        
        This outlines that the program tries to use a single library to convert the file before using multiple.  If a single library is unable to 
        read and write the needed formats, it tries to import with one, export to a temporary format, and export with the other.  An example of 
        using a single library is if a user wants to read a .obj and write to a .fbx.  The FBX SDK can handle reading and writing those particular file
        types, so it will be used ot do the conversion.  An example of needing to use both libraries is if a user wants to convert a .ply to a .fbx.
        Assimp can read .ply files, but cannot write to .fbx.  The FBX SDK can write to .fbx files but not read .ply.  Therefore, assimp is used to 
        read the .ply, write to a .dae (common file type).  The FBX SDK then reads the .dae and writes to a .fbx.

    \subsection{Design Details}

    \subsubsection{Overview}

    The file converison software is written in C++.  The structure of the program is object oriented, where classes are defined where the functionality needed
    in the program is defined.  Instances of the classes will be created when needed.  
    The high level view of the program is:
    \begin{enumerate}
        \item Parse command line arguments
        \item Convert the file
        \item Print error messages if errors occured
    \end{enumerate}

    The parsing the command line arguments section may fail if the user does not supply the correct arguments.  A flag is set after parsing to indicate
    whether the correct arguments were supplied.  If an error occurrs during file conversion, the error will be denoted by an integer error code.  
    During file conversion, if a single library could not convert it on its own, an extra file will be created as an intermediate file.

    \subsubsection{Code Structure}
    The file conversion software is broken into two main sections: parameter parsing and file conversion.

    \paragraph{Parameter Parsing}
    \hfill \break
    The parameter parsing code is in a class called ParseParameters.  ParseParameters has a constructor that takes the number of command line arguments, 
    and the command line arguments.  It will parse the values needed out into member variables that are public.  It will ignore invalid arguments,
    and print a usage statement if the correct arguments are not supplied.  When printing the usage statement, cout is used to write to standard out.

    After processing the command line arguments, the member variables in the class will be set with the appropriate information.  The member variables are:

    \begin{tabular}{l l}
        \centering
        success & bool \\
        & True if the needed information is set, false otherwise \\

        inputFile & string \\
        & The name/path of the file to convert \\

        outputFile & string \\
        & The name/path of the file to export to \\

        fileExtention & string \\
        & The file extention of the output file
    \end{tabular}

    If the success variable is false, the other member variables possibly have bad data that should not be used.

    \paragraph{File Conversion}
    \hfill \break
    The file conversion portion of the program is the meat of the functionality.  It takes an input file, and tries to convert it to the file type requested.
    This section implements the two libraries.  Each library is implemented in a class inherited from an abstract AbstractConverter converter class.  The two 
    library implementation classes are called AssimpConverter and FBXConverter.  A class named FileConverter contains the logic on determining which 
    library/libraries to use when converting the file.

    \subparagraph{AbstractConverter}
    \hfill \break
    The AbstractConverter is an abstract class that acts like an interface for the child classes.  The abstract methods are:
    \begin{itemize}
        \item SupportsInputFileType
        \begin{itemize}
            \item Return true if the converter can read in a file with a given file type
        \end{itemize}

        \item SupportsOutputFileType
        \begin{itemize}
            \item Return true if the converter can write to a file with a given type
        \end{itemize}

        \item ConvertFile
        \begin{itemize}
            \item Performs the file conversion
        \end{itemize}
    \end{itemize}

    An emum is defined, called Result, that provides a more self documenting way to return information from functions.  Values less than zero are errors, while
    value greater than zero are successes.  The levels of the enum are:
    
    \begin{tabular}{l l}
        \centering
        Failed &\\
        IOError &\\
        SceneNotLoaded &\\
        NotInitialized &\\
        FileTypeNotSupported &\\
        Success &
    \end{tabular}

    \subparagraph{AssimpConverter}
    \hfill \break
    The AssimpConverter inherits from the AbstractConverter and uses the Open Asset Import Library for file conversion.  
    The file type supported methods are implementd by adding the supported file types to a set, and checking whether the questionable type is in the set.
    The list of file types supported is taken from the Open Asset Import Library website's list of supported input file types.  
    The output file types list comes from the same location.
    When converting a file, optimizations may be performed on the file to remove unnecessary/duplicate information.  For example, when importing a file, 
    repeatedverticies in the meshes will be condensed into one, to help reduce the size of the file.

    \subparagraph{FBXConverter}
    \hfill \break
    The FBXConverter inherits the AbstractConverter and uses the FBX SDK to import and export files.
    THe file type input and output lists are derived from the FBX SDK website.

    \subparagraph{FileConverter}
    \hfill \break
    The FileConverter looks at the input and output file types, and determines which library/libraries needed to convert the file.
    It tries see if a single library can do the conversion.  If not, then both libraries are used by exporting from one into a 
    temporary file (.dae) and converting that to the final file type. After comparing the read/write lists between the libraries,
    the DAE file type was common between the two, and included features that other file types did not.  Therefore, it was chosen
    to have DAE as the common intermediate file type.

 \begin{comment}
    \section{Major Component \#1 }

    {\bf If the following makes sense, use this outline, if not then modify the outline}


    This section is used to describe the design details for each of the major components 
    in the system.    Note that this chapter is critical for all tracks.  Research tracks would do experimental design here where other tracks would include the engineering design aspects.    This section is not brief and requires the necessary detail that 
    can be used by the reader to truly understand the architecture and implementation 
    details without having to dig into the code.    Sample algorithm:  Algorithm~\ref{alg1}.  This algorithm environment is automatically placed - meaning it floats.   You don't have to worry about placement or numbering.  

    \begin{algorithm} [tbh]                     % enter the algorithm environment
    \caption{Calculate $y = x^n$}          % give the algorithm a caption
    \label{alg1}                           % and a label for \ref{} commands later in the document
    \begin{algorithmic}                    % enter the algorithmic environment
        \REQUIRE $n \geq 0 \vee x \neq 0$
        \ENSURE $y = x^n$
        \STATE $y \Leftarrow 1$
        \IF{$n < 0$}
            \STATE $X \Leftarrow 1 / x$
            \STATE $N \Leftarrow -n$
        \ELSE
            \STATE $X \Leftarrow x$
            \STATE $N \Leftarrow n$
        \ENDIF
        \WHILE{$N \neq 0$}
            \IF{$N$ is even}
                \STATE $X \Leftarrow X \times X$
                \STATE $N \Leftarrow N / 2$
            \ELSE[$N$ is odd]
                \STATE $y \Leftarrow y \times X$
                \STATE $N \Leftarrow N - 1$
            \ENDIF
        \ENDWHILE
    \end{algorithmic}
    \end{algorithm}
    Citations look like~\cite{Choset:2005:PRM, arkin2009governing, lavalle2006}  and~\cite{wiki:asimo,lumelsky:1987, nolfi2000evolutionary}.  These are done automatically.  Just fill in the database {\tt designrefs.bib} using the same field structure as the other entries.  Then pdflatex the document, bibtex the document and pdflatex twice again.  The first pdflatex creates requests for bibliography entries.
    The bibtex extracts and formats the requested entries.  The next pdflatex puts them in order and assigns labels.  The final pdflatex replaces references in the text with the assigned labels.
    The bibliography is automatically constructed.  
    


    \subsection{Technologies  Used}
    This section provides a list of technologies used for this component.  The details 
    for the technologies have already been provided in the Overview section. 

    \subsection{Component  Overview}
    This section can take the form of a list of features. 

    \subsection{Phase Overview}
    This is an extension of the Phase Overview above, but specific to this component. 
    It is meant to be basically a brief list with space for marking the phase status. 

    \subsection{ Architecture  Diagram}
    It is important to build and maintain an architecture diagram.  However, it may 
    be that a component is best described visually with a data flow diagram. 


    \subsection{Data Flow Diagram}
    It is important to build and maintain a data flow diagram.  However, it may be 
    that a component is best described visually with an architecture diagram. 


    \subsection{Design Details}
    This is where the details are presented and may contain subsections.   Here is an example code listing:
    \begin{lstlisting}
    #include <stdio.h>
    #define N 10
    /* Block
    * comment */
    
    int main()
    {
        int i;
    
        // Line comment.
        puts("Hello world!");
    
        for (i = 0; i < N; i++)
        {
            puts("LaTeX is also great for programmers!");
        }
    
        return 0;
    }
    \end{lstlisting}
    This code listing is not floating or automatically numbered.  If you want auto-numbering, but it in the algorithm environment (not algorithmic however) shown above.

\end{comment}
